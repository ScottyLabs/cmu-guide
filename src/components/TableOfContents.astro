---
import { HamburgerMenu } from "svelte-radix";

type Heading = {
	depth: number;
	slug: string;
	text: string;
};

interface Props {
	headings: Heading[];
}

const { headings } = Astro.props;
const filteredHeadings = headings.filter((h) => h.depth === 2 || h.depth === 3);
---

<aside
	class="hidden lg:block w-64 fixed right-0 top-28 h-auto text-sm px-4"
	aria-label="On this page"
	data-toc
>
	<div class="bg-white/0 dark:bg-transparent">
		<div class="flex items-center gap-2 mb-3">
			<HamburgerMenu class="w-4 h-4 text-zinc-500 dark:text-zinc-400" />
			<p class="text-zinc-500 dark:text-zinc-400">On this page</p>
		</div>

		<ul
			class="space-y-2 border-l border-zinc-200 dark:border-zinc-700 pl-4"
		>
			{
				filteredHeadings.map((h) => (
					<li class={h.depth === 3 ? "ml-4" : ""}>
						<a
							href={`#${h.slug}`}
							data-toc-link
							data-slug={h.slug}
							class="block text-zinc-500 hover:text-zinc-900 dark:text-zinc-400 dark:hover:text-zinc-100 transition-colors"
						>
							{h.text}
						</a>
					</li>
				))
			}
		</ul>
	</div>
</aside>

<script>
	function initTOC() {
		const links = document.querySelectorAll("[data-toc-link]");
		if (!links.length) return;

		let userClicked = false;
		let clickTimeout: ReturnType<typeof setTimeout> | null = null;

		function setActiveLink(slug: string) {
			links.forEach((link) => {
				link.classList.remove(
					"!text-zinc-900",
					"dark:!text-zinc-100",
					"font-medium",
				);
			});

			const tocLink = document.querySelector(
				`[data-toc-link][data-slug="${slug}"]`,
			);

			if (tocLink) {
				tocLink.classList.add(
					"!text-zinc-900",
					"dark:!text-zinc-100",
					"font-medium",
				);
			}
		}

		// Handle clicks on TOC links
		links.forEach((link) => {
			link.addEventListener("click", (e) => {
				const slug = link.getAttribute("data-slug");
				if (slug) {
					userClicked = true;
					setActiveLink(slug);

					// Clear any existing timeout
					if (clickTimeout) {
						clearTimeout(clickTimeout);
					}

					// Re-enable intersection observer after scroll settles
					clickTimeout = setTimeout(() => {
						userClicked = false;
					}, 1000);
				}
			});
		});

		const observer = new IntersectionObserver(
			(entries) => {
				// Don't update based on scroll if user just clicked
				if (userClicked) return;

				entries.forEach((entry) => {
					const id = entry.target.getAttribute("id");
					if (entry.isIntersecting && id) {
						setActiveLink(id);
					}
				});
			},
			{
				rootMargin: "-100px 0px -66%",
				threshold: 1,
			},
		);

		// Observe all headings
		const headings = document.querySelectorAll("h2[id], h3[id]");
		headings.forEach((heading) => observer.observe(heading));

		// Cleanup
		return () => {
			headings.forEach((heading) => observer.unobserve(heading));
		};
	}

	initTOC();

	// Re-initialize after Astro page transitions
	document.addEventListener("astro:after-swap", initTOC);
</script>
